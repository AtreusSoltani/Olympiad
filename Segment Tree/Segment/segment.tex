\def\problemCode{\LR{Segment Tree}}
\def\problemFarsiTitle{درخت بازه‌ای}

\begin{problem}

با استفاده از 
\LR{fenwick}
تونستیم به پرسش‌های عوض کردن یک خانه و پیدا کردن جمع یک بازه جواب بدیم.
دیدیم که
\LR{fenwick}
برای اینکه جواب پرسش یک بازه رو پیدا کنه، باید پرسش این ویژگی رو داشته باشه که
\LR{partially}
جواب داده بشه. یعنی بتونیم جواب برای بازه
$[l, r]$
رو از روی جواب 
$[1, l - 1]$
و
$[1, r]$
پیدا کنیم. برای مثال این ویژگی رو پرسش‌های 
جمع و ضرب دارند ولی خیلی از عملیات‌ها مثل ماکسیمم و
\LR{gcd}
این ویژگی رو ندارند
.
در ادامه مسئله‌ای که حل می‌کنیم رو توضیح می‌دیم.

آرایه‌ای از اعداد داریم. تعدادی پرسش به یکی از حالات زیر می‌آید:
\begin{itemize}
  \item 
  \LR{change $idx$ $value$}:
    مقدار خانه
    $idx$
    را به
    $value$
    تغییر بده.

  \item 
  \LR{getmax $L$ $R$}:
    ماکسیمم بازه
    $[L, R]$
    را خروجی بده.
\end{itemize}
هدف انجام هر پرسش در 
$\mathcal{O}(\log n)$
می‌باشد که 
$n$
طول آرایه است.

فرض کنید که 
$n = 8$
است.
به درخت زیر توجه کنید.
\input{tikzpictures/segtree}
هر راس این درخت دودویی کامل یک بازه از آرایه را نشان می‌دهد. 
برگ‌های آن بازه‌های تک عضوی هستند و 
بازه هر راس اجتماع بازع دو بچه‌ی آن است. 
تعداد راس‌های این درخت دقیقا
$2n - 1$
است و ارتفاع آن نیز
$\lceil \log_n rceil$
می‌باشد.

در هر راس ماکسیمم بازه مربوط به آن را ذخیره می‌کنیم.
حال بررسی می‌کنیم 
هر تغییر در آرایه چه تغییری در درخت می‌دهد و 
برای جواب دادن به هر پرسش باید چه کنیم.

\mysection{تغییر یک خانه}
ابتدا فرض کنید در مثال 
$n = 8$
مقدار خانه 
$6$
تغییر کند. بدیهی است که راس‌هایی از درخت ممکن است مقدارشان تغییر کند که 
$6$
در بازه‌ی مربوط به آن حضور داشته باشد.
این خانه‌ها در شکل زیر علامت زده شده‌اند.

ویژگی این درخت این است که هر عضو از آرایه در مسیر برگ آن به ریشه حضور دارد.
اگر از ریشه به پایین بیاییم، 
هر اندیسی در بازه مربوط به دقیقا یکی از بچه‌های ریشه وجود دارد.
به طور بازگشتی می‌توان همه راس‌هایی که دچار تغییر می‌شوند را آپدیت کرد.
اگر راس دلخواهی از درخت باید تغییر کند، ابتدا بچه‌ی مربوطه‌اش را تغییر می‌دهیم و سپس مقدار آن را ماکسیمم دو بچه‌اش قرار می‌دهیم.

\input{tikzpictures/segtree-6}

شبه‌کد آن به این صورت است.

\LR{
\inputminted{cpp}{codes/segchange.cpp}
}

\mysection{گرفتن یک بازه}
دوباره 
در مثال
$n = 8$
فرض کنید ماکسیمم بازه
$[2, 7)$
را می‌خواهیم پیدا کنیم. از ریشه شروع می‌کنیم و در هر راسی که هستیم به دنبال پیدا کردن
ماکسیمم اشتراک راس و بازه مربوطه هستیم.
اگر بازه درخت کاملا درون بازه پرسش قرار داشت، مقدار ذخیره شده راس درخت را برمی‌گردانیم و 
در غیر این صورت به صورت بازگشتی از دو بچه‌ی آن ماکسیمم اشتراکشان را پیدا می‌کنیم و سپس ماکسیمم دو مقدار بازگردانده شده را برمی‌گردانیم.

\input{tikzpictures/segtree-2-7}

\LR{
  \inputminted{cpp}{codes/segget.cpp}
}

\mysection{جزئیات پیاده‌سازی}

شماره رئوس درخت مانند شکل زیر است. خاصیت این شماره‌گذاری این است که شماره‌ی بچه‌های راس 
$x$
برابر
$2x$
و
$2x + 1$
می‌باشد.

\input{tikzpictures/completetree}

\LR{
  \inputminted{cpp}{codes/segcode.cpp}
}

\end{problem}